<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DARIA Remote Interview</title>
    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f7f9fc;
            color: #333;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .interview-panel {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        h1, h2, h3 {
            margin-top: 0;
            color: #333;
        }
        
        .message-container {
            height: 400px;
            overflow-y: auto;
            padding: 15px;
            background-color: #fff;
            border: 1px solid #eee;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        
        .message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 8px;
            max-width: 85%;
        }
        
        .user-message {
            background-color: #e9f5ff;
            color: #0066cc;
            border-left: 4px solid #0066cc;
            margin-left: auto;
            margin-right: 0;
        }
        
        .assistant-message {
            background-color: #f0f4f8;
            color: #333;
            border-left: 4px solid #9E9E9E;
            margin-right: auto;
            margin-left: 0;
        }
        
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            resize: vertical;
            min-height: 80px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        button {
            padding: 12px 20px;
            background-color: #0066cc;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            margin-right: 8px;
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: 500;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #0058b3;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        
        .control-panel {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
        }
        
        .status-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-radius: 8px;
            border: 1px solid #eee;
        }
        
        .status-item {
            display: flex;
            align-items: center;
        }
        
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-active {
            background-color: #4CAF50;
            box-shadow: 0 0 5px #4CAF50;
            animation: pulse 1.5s infinite;
        }
        
        .status-connected {
            background-color: #4CAF50;
        }
        
        .status-inactive {
            background-color: #F44336;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7);
            }
            70% {
                box-shadow: 0 0 0 5px rgba(76, 175, 80, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(76, 175, 80, 0);
            }
        }
        
        .collapsible-panel {
            margin-top: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .collapsible-header {
            background-color: #f7f9fc;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
        }
        
        .collapsible-header h3 {
            margin: 0;
            font-size: 16px;
        }
        
        .toggle-icon {
            font-size: 18px;
            font-weight: bold;
        }
        
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        
        .info-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            padding: 15px;
        }
        
        .info-item {
            display: flex;
            flex-direction: column;
        }
        
        .info-label {
            font-weight: bold;
            font-size: 14px;
            color: #555;
        }
        
        .info-value {
            font-size: 15px;
            margin-top: 4px;
        }
        
        .log-container {
            height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: #000;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            margin: 10px;
        }
        
        .debug-controls {
            display: flex;
            gap: 10px;
            padding: 10px;
        }
        
        .debug-btn {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: 1px solid #3e8e41;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .debug-btn:hover {
            background-color: #3e8e41;
        }
        
        .debug-btn:active {
            background-color: #357a38;
        }
        
        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-word;
        }
        
        .info-log {
            color: #4CAF50;
        }
        
        .warn-log {
            color: #FFC107;
        }
        
        .error-log {
            color: #F44336;
        }
        
        .stt-log {
            color: #2196F3;
        }
        
        .tts-log {
            color: #9C27B0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="interview-panel">
            <h1>Research Session</h1>
            <p>Thank you for participating in this research session. Please speak naturally when responding to questions.</p>
            
            <div class="status-container">
                <div class="status-item">
                    <span class="status-indicator" id="connection-status"></span>
                    <span id="connection-status-text">Connecting...</span>
                </div>
                <div class="status-item">
                    <span id="timer">00:00</span>
                </div>
            </div>
            
            <div class="interview-panel">
                <h2>Interview Conversation</h2>
                <div class="message-container" id="message-container">
                    <!-- Messages will appear here -->
                    <div class="message assistant-message">Connect to start a conversation</div>
                </div>
                
                <div style="display: flex; justify-content: flex-end; margin-bottom: 10px;">
                    <button id="copy-conversation" class="debug-btn">Copy Conversation</button>
                </div>
                
                <h3>Your Response:</h3>
                <textarea id="user-input" placeholder="Type your response here..." disabled></textarea>
                
                <div class="control-panel">
                    <button id="send-message" disabled>Send Message</button>
                    <button id="end-interview" disabled>End Interview</button>
                </div>
            </div>
            
            <!-- Session Information Panel (Collapsible) -->
            <div class="collapsible-panel">
                <div class="collapsible-header" id="session-info-header">
                    <h3>Session Information</h3>
                    <span class="toggle-icon">+</span>
                </div>
                <div class="collapsible-content" id="session-info-content">
                    <div class="info-grid">
                        <div class="info-item">
                            <span class="info-label">Guide:</span>
                            <span class="info-value" id="guide-name">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Project:</span>
                            <span class="info-value" id="project-name">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Type:</span>
                            <span class="info-value" id="session-type">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">AI Character:</span>
                            <span class="info-value" id="ai-character">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Status:</span>
                            <span class="info-value" id="session-status">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Date:</span>
                            <span class="info-value" id="session-date">Loading...</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Participant:</span>
                            <span class="info-value" id="participant-name">Loading...</span>
                        </div>
                        <div class="info-item" style="display: flex; flex-direction: row; align-items: center; justify-content: space-between;">
                            <div>
                                <span class="info-label">Session ID:</span>
                                <span class="info-value" id="session-id-display">Loading...</span>
                            </div>
                            <button id="copy-session-id" class="debug-btn" style="margin-left: 10px; padding: 4px 8px; font-size: 12px;">Copy ID</button>
                        </div>
                    </div>
                    <div class="debug-controls" style="justify-content: flex-end;">
                        <button id="copy-session-info" class="debug-btn">Copy Session Info</button>
                    </div>
                </div>
            </div>
            
            <!-- Debug Information -->
            <div class="collapsible-panel" id="debug-panel">
                <div class="collapsible-header" id="debug-log-header">
                    <h3>Debug Log</h3>
                    <span class="toggle-icon">−</span>
                </div>
                <div class="collapsible-content" style="max-height: 300px; overflow-y: auto;">
                    <div id="debug-log" class="debug-log"></div>
                </div>
            </div>

            <!-- Add a scrollable debug log panel that's always visible -->
            <div class="interview-panel" id="always-visible-debug">
                <h3>Debug Log (Always Visible)</h3>
                <div style="height: 300px; overflow-y: auto; background-color: #f8f9fa; padding: 10px; border: 1px solid #ddd; border-radius: 5px;">
                    <div id="debug-log-visible" class="debug-log"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let ttsAudio = new Audio();
        let recognition = null;
        let ttsActive = false;
        let sttActive = false;
        let apiPort = 5025;
        let sessionId = null;
        let lastAssistantMessage = "";
        let isConnected = false;
        let startTime = null;
        let timerInterval = null;
        let guideInfo = null;
        
        // DOM Elements
        const connectionStatus = document.getElementById('connection-status');
        const connectionStatusText = document.getElementById('connection-status-text');
        const messageContainer = document.getElementById('message-container');
        const userInput = document.getElementById('user-input');
        const sendMessageBtn = document.getElementById('send-message');
        const endInterviewBtn = document.getElementById('end-interview');
        const timer = document.getElementById('timer');
        
        // DOM Content Loaded - Main Entry Point
        document.addEventListener('DOMContentLoaded', function() {
            log("Document loaded, initializing interview interface", 'info');
            
            // Initialize variables
            sessionId = "{{ session_id }}";
            apiPort = {{ port|default(5025) }};
            apiUrl = `http://${window.location.hostname}:${apiPort}`;
            
            // Get DOM elements
            messageContainer = document.getElementById('message-container');
            userInput = document.getElementById('message-input');
            sendMessageBtn = document.getElementById('send-message');
            copyConvoBtn = document.getElementById('copy-conversation');
            endInterviewBtn = document.getElementById('end-interview');
            connectionStatus = document.getElementById('connection-indicator');
            connectionStatusText = document.getElementById('connection-status-text');
            
            // Initialize UI
            initUI();
            
            // Initialize TTS
            initTTSAudio();
            
            // Setup the collapsible panels
            setupCollapsiblePanels();
            
            // Initialize event listeners
            initEventListeners();
            
            // Check API services
            checkServices().then(function(serviceStatus) {
                if (serviceStatus.success) {
                    log(`Services status - TTS: ${serviceStatus.tts_available ? 'Available' : 'Unavailable'}, STT: ${serviceStatus.stt_available ? 'Available' : 'Unavailable'}`, 'info');
                    
                    // Connect to server
                    connectToServer();
                } else {
                    log('Service check failed', 'error');
                }
            }).catch(function(error) {
                log(`Service check error: ${error.message}`, 'error');
            });
            
            log("Initialization sequence complete", 'info');
        });
        
        // Check API services
        async function checkServices() {
            try {
                log('Checking API services...', 'info');
                const response = await fetch(`http://${window.location.hostname}:${apiPort}/api/check_services`);
                
                if (!response.ok) {
                    throw new Error(`Service check failed with status ${response.status}`);
                }
                
                const data = await response.json();
                
                // Convert API response format (tts_service, stt_service) to expected format (tts_available, stt_available)
                const result = {
                    success: true,
                    tts_available: data.tts_service || false,
                    stt_available: data.stt_service || false
                };
                
                log(`Services status - TTS: ${result.tts_available ? 'Available' : 'Unavailable'}, STT: ${result.stt_available ? 'Available' : 'Unavailable'}`, 'info');
                return result;
            } catch (error) {
                log(`Service check error: ${error.message}`, 'error');
                return {
                    success: false,
                    tts_available: false,
                    stt_available: false,
                    error: error.message
                };
            }
        }
        
        // Initialize TTS audio element
        function initTTSAudio() {
            log("Initializing TTS audio element", 'info');
            try {
                ttsAudio = new Audio();
                
                // Set audio properties
                ttsAudio.autoplay = false; // We'll manually control playback
                ttsAudio.preload = 'auto';
                
                // Add event listeners
                ttsAudio.addEventListener('play', () => {
                    log("Audio playback started", 'tts');
                    ttsActive = true;
                    updateStatus();
                });
                
                ttsAudio.addEventListener('ended', () => {
                    log("Audio playback ended", 'tts');
                    ttsActive = false;
                    updateStatus();
                    
                    // Start STT after TTS finishes with a short delay
                    setTimeout(() => {
                        if (!sttActive) {
                            log("Starting speech recognition after TTS", 'stt');
                            startSpeechRecognition();
                        }
                    }, 300);
                });
                
                ttsAudio.addEventListener('error', (error) => {
                    let errorMessage = "Unknown audio error";
                    
                    // Get more detailed error information
                    if (ttsAudio.error) {
                        switch (ttsAudio.error.code) {
                            case MediaError.MEDIA_ERR_ABORTED:
                                errorMessage = "Audio playback aborted";
                                break;
                            case MediaError.MEDIA_ERR_NETWORK:
                                errorMessage = "Network error during audio loading";
                                break;
                            case MediaError.MEDIA_ERR_DECODE:
                                errorMessage = "Audio decoding error";
                                break;
                            case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                errorMessage = "Audio format not supported";
                                break;
                            default:
                                errorMessage = `Unknown error: ${ttsAudio.error.code}`;
                        }
                    }
                    
                    log(`TTS Audio error: ${errorMessage}`, 'error');
                    ttsActive = false;
                    updateStatus();
                });
                
                // Test audio capabilities by loading a tiny silent audio clip
                testAudioCapabilities();
                
                return true;
            } catch (e) {
                log(`Error initializing TTS audio: ${e.message}`, 'error');
                return false;
            }
        }
        
        // Test browser audio capabilities
        function testAudioCapabilities() {
            try {
                // Create a small silent audio clip to test audio support
                const silentAudio = new Audio("data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjI5LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWGluZwAAAA8AAAACAAADkADc3NwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+xDE3gAAANIAYAAAAA0gAAAAATEFMRTMuMTAwVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/9A3MTnP/NSCB9lXcwsKCvH/9Sxf////////////pNJ3/+MYxOIALUGAeNAAQBDAKG0ABgAR////////+pKhVVf////oAgCAIB0T//0EAXv////6QQDon//8AgHAQBA5//5BAXP/0gQBgEAQDU//9AEAwCAIHRO//QBAP////0AQBAEAwdE7//QBAPggCAY//+gCAYBAEDon//1D/+xDE3gAOrN0YxgAAMKRcfEsOAgf////QBAMAgCB0T//0AQBAP////5AgP/////pAgGAQBA6J3/6AIBgEAQGU//0AQDAIBAPCY//0g/6L//UlQZFP//1OdIf//+GAAACAfD//8EPf/IICAQiRNBMJoQ");
                
                silentAudio.oncanplaythrough = () => {
                    log("Browser audio capabilities verified", 'info');
                };
                
                silentAudio.onerror = () => {
                    log("Browser audio test failed - may have issues with TTS playback", 'warn');
                };
                
                // Start loading the audio
                silentAudio.load();
                
                // Check Web Speech API availability
                if (window.SpeechRecognition || window.webkitSpeechRecognition) {
                    log("Speech Recognition API is available", 'info');
                } else {
                    log("Speech Recognition API not supported in this browser", 'warn');
                }
                
                if (window.speechSynthesis) {
                    log("Speech Synthesis API is available", 'info');
                } else {
                    log("Speech Synthesis API not supported in this browser", 'warn');
                }
                
            } catch (e) {
                log(`Browser audio test exception: ${e.message}`, 'warn');
            }
        }
        
        // Connect to API server
        async function connectToServer() {
            try {
                // Check if API server is available
                log(`Connecting to API server on port ${apiPort}`, 'info');
                const response = await fetch(`http://${window.location.hostname}:${apiPort}/api/health`);
                if (response.ok) {
                    isConnected = true;
                    updateStatus();
                    log('API server connection successful', 'info');
                    
                    // Enable UI
                    userInput.disabled = false;
                    sendMessageBtn.disabled = false;
                    endInterviewBtn.disabled = false;
                    
                    // Fetch initial messages if session ID is provided
                    if (sessionId) {
                        log(`Loading messages for session: ${sessionId}`, 'info');
                        fetchLatestMessages();
                    } else {
                        console.error("No session ID provided!");
                        addMessage("Error: No session ID provided", 'error');
                        log('Error: No session ID provided', 'error');
                    }
                } else {
                    console.error("API server health check failed:", await response.text());
                    connectionStatusText.textContent = "Connection Failed";
                    connectionStatus.classList.add('status-inactive');
                    log(`API server health check failed: ${await response.text()}`, 'error');
                }
            } catch (error) {
                console.error("Error connecting to server:", error);
                connectionStatusText.textContent = "Connection Error";
                connectionStatus.classList.add('status-inactive');
                log(`Connection error: ${error.message}`, 'error');
            }
        }
        
        // Fetch latest messages from the server
        async function fetchLatestMessages() {
            try {
                log(`Fetching messages for session: ${sessionId}`, 'info');
                const response = await fetch(`http://${window.location.hostname}:${apiPort}/api/session/${sessionId}/messages`);
                
                if (!response.ok) {
                    log(`API error ${response.status}: ${await response.text()}`, 'error');
                    return false;
                }
                
                const data = await response.json();
                let found = false;
                
                if (data.messages && data.messages.length > 0) {
                    // Check if we have any non-system messages
                    const nonSystemMessages = data.messages.filter(m => m.role !== 'system');
                    
                    if (nonSystemMessages.length === 0) {
                        // We only have system messages, so we should generate a welcome message
                        log('Session only has system messages. Generating welcome message.', 'info');
                        generateAndSendWelcomeMessage();
                        return true;
                    }
                    
                    // Clear existing messages
                    messageContainer.innerHTML = '';
                    
                    // First pass: add all messages to UI
                    for (const message of data.messages) {
                        if (message.role !== 'system') {
                            // Don't play TTS yet - just add to UI
                            const messageElem = document.createElement('div');
                            messageElem.className = 'message ' + (message.role === 'assistant' ? 'assistant-message' : 'user-message');
                            messageElem.textContent = message.content;
                            
                            messageContainer.appendChild(messageElem);
                            
                            // If this is an assistant message, possibly save it for TTS
                            if (message.role === 'assistant') {
                                // Save the most recent assistant message for TTS
                                lastAssistantMessage = message.content;
                            }
                            
                            found = true;
                            log(`Added ${message.role} message to UI: "${message.content.substring(0, 30)}${message.content.length > 30 ? '...' : ''}"`, 'info');
                        }
                    }
                    
                    // Scroll to bottom
                    messageContainer.scrollTop = messageContainer.scrollHeight;
                    
                    // Find the most recent assistant message to play
                    let mostRecentAssistantMessage = null;
                    for (let i = data.messages.length - 1; i >= 0; i--) {
                        if (data.messages[i].role === 'assistant') {
                            mostRecentAssistantMessage = data.messages[i].content;
                            break;
                        }
                    }
                    
                    // Now play the most recent assistant message if found
                    if (mostRecentAssistantMessage) {
                        const isFirstMessage = data.messages.filter(m => m.role === 'user').length <= 1;
                        if (isFirstMessage) {
                            log("Playing initial welcome message", 'tts');
                        } else {
                            log("Playing latest assistant response", 'tts');
                        }
                        lastAssistantMessage = mostRecentAssistantMessage;
                        playTTS(mostRecentAssistantMessage);
                    } else {
                        // No assistant messages found, but we have other messages
                        // This is unusual but we should generate a welcome message
                        log('No assistant messages found in session. Generating welcome message.', 'info');
                        generateAndSendWelcomeMessage();
                    }
                } else {
                    log('No messages found in session', 'warn');
                    // Auto-generate a welcome message when no messages exist
                    generateAndSendWelcomeMessage();
                }
                
                return found;
            } catch (error) {
                log(`Error fetching latest messages: ${error.message}`, 'error');
                // Even on error, try to generate a welcome message to ensure the interview can continue
                try {
                    generateAndSendWelcomeMessage();
                    return true;
                } catch (welcomeError) {
                    log(`Failed to generate welcome message after error: ${welcomeError.message}`, 'error');
                    return false;
                }
            }
        }
        
        // Generate and send a welcome message based on character
        function generateAndSendWelcomeMessage() {
            if (!guideInfo) {
                // If we don't have guide info yet, try to load it first
                loadSessionInfo().then(() => {
                    if (guideInfo) {
                        createAndSendWelcomeMessage();
                    } else {
                        // Still no guide info, use a generic welcome message
                        const genericWelcome = "Hello! Thank you for joining me for this interview. I'm your AI assistant, and I'll be asking you some questions today. Let's begin when you're ready.";
                        createAndDisplayWelcomeMessage(genericWelcome, 'assistant');
                    }
                }).catch(error => {
                    log(`Error loading session info for welcome message: ${error.message}`, 'error');
                    // Use generic welcome message on error
                    const genericWelcome = "Hello! Thank you for joining me for this interview. I'm your AI assistant, and I'll be asking you some questions today. Let's begin when you're ready.";
                    createAndDisplayWelcomeMessage(genericWelcome, 'assistant');
                });
            } else {
                createAndSendWelcomeMessage();
            }
        }
        
        // Create and send a welcome message using the guide info
        function createAndSendWelcomeMessage() {
            log('Creating welcome message for session', 'info');
            
            // Get character information
            const character = guideInfo.character_select ? guideInfo.character_select.toLowerCase() : '';
            const characterName = character || guideInfo.ai_character || 'assistant';
            log(`Using character: ${characterName} for welcome message`, 'info');
            
            let welcomeMessage = "Hello! Thank you for joining me for this interview. I'm your AI assistant, and I'll be asking you some questions today. Let's begin when you're ready.";
            
            // Use character-specific welcome messages for better personality alignment
            if (character === 'eurekia') {
                welcomeMessage = "Hello! I'm Eurekia, your innovation interview assistant. I'm here to explore opportunities and insights with you. I'll be asking questions to help identify innovation potential and strategic insights. How are you doing today?";
            } else if (character === 'researcher') {
                welcomeMessage = "Hello! I'm your research assistant for today's session. I'll be asking you some questions to help gather valuable insights for our study. My approach is methodical and focused on collecting meaningful data. Shall we begin?";
            } else if (character === 'interviewer') {
                welcomeMessage = "Welcome to this interview session. I'll be guiding our conversation today to learn more about your experiences and perspectives. I aim to create a comfortable space for open dialogue. How are you feeling today?";
            } else if (character === 'skeptica') {
                welcomeMessage = "Hello there. I'm Skeptica, and I'll be conducting this interview with a critical eye. I believe in questioning assumptions and digging deeper into claims. I hope you're ready for some thought-provoking questions.";
            } else if (character === 'askia') {
                welcomeMessage = "Greetings! I'm Askia, your interview question specialist. I'm here to help refine and develop effective research questions. I'm particularly interested in how you approach research design and methodology. Shall we get started?";
            } else if (character === 'synthia') {
                welcomeMessage = "Hi there! I'm Synthia, and I'll be guiding our conversation today. I specialize in bringing together diverse perspectives to create comprehensive insights. I look forward to our discussion and hearing your thoughts.";
            } else if (character === 'thesea') {
                welcomeMessage = "Hello. I'm Thesea, and I'll be conducting this interview to explore big-picture themes and patterns. My focus is on identifying underlying currents and connections that might not be immediately obvious. Let's begin our exploration.";
            } else if (character === 'odessia') {
                welcomeMessage = "Welcome! I'm Odessia, your journey guide for this interview. I believe every conversation is a unique journey of discovery. I'll be asking questions that help us navigate toward meaningful insights about your experiences and perspectives.";
            } else if (character === 'daria') {
                welcomeMessage = "Hello! I'm Daria, your interview assistant. I'm designed to facilitate insightful conversations through thoughtful questions and active listening. I'm looking forward to our discussion today.";
            }
            
            log(`Created welcome message for character ${characterName}`, 'info');
            
            // Get the interview prompt to add as context for the AI
            const interviewPrompt = guideInfo.interview_prompt || guideInfo.prompt || "";
            log(`Using interview prompt: ${interviewPrompt.substring(0, 50)}...`, 'info');
            
            // First display welcome message in UI for immediate feedback
            createAndDisplayWelcomeMessage(welcomeMessage, characterName);
            
            // First send a system message with the interview prompt to establish context
            if (interviewPrompt) {
                fetch(`http://${window.location.hostname}:${apiPort}/api/session/${sessionId}/add_message`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: interviewPrompt,
                        role: 'system'
                    })
                }).then(response => {
                    if (!response.ok) {
                        throw new Error(`Error saving system prompt: ${response.status}`);
                    }
                    return response.json();
                }).then(data => {
                    log('System prompt message saved to session', 'info');
                    
                    // Now send the welcome message as assistant
                    sendWelcomeMessage(welcomeMessage);
                }).catch(error => {
                    log(`Failed to save system prompt: ${error.message}`, 'error');
                    
                    // Still try to send welcome message even if system message fails
                    sendWelcomeMessage(welcomeMessage);
                });
            } else {
                // If no prompt, just send welcome message
                sendWelcomeMessage(welcomeMessage);
            }
        }
        
        // Create and display a welcome message in the UI
        function createAndDisplayWelcomeMessage(welcomeMessage, characterName) {
            // Add welcome message to UI
            const messageElem = document.createElement('div');
            messageElem.className = 'message assistant-message';
            messageElem.textContent = welcomeMessage;
            
            // Clear any existing messages if this is the first message
            if (messageContainer.childElementCount === 0 || 
                (messageContainer.childElementCount === 1 && messageContainer.firstChild.textContent === "Connect to start a conversation")) {
                messageContainer.innerHTML = '';
            }
            
            messageContainer.appendChild(messageElem);
            messageContainer.scrollTop = messageContainer.scrollHeight;
            
            // Save and play the welcome message
            lastAssistantMessage = welcomeMessage;
            playTTS(welcomeMessage);
            
            log(`Displayed welcome message from ${characterName} in UI`, 'info');
        }
        
        // Send message to API server
        async function sendMessage(text) {
            const input = text || userInput.value.trim();
            
            if (!input) {
                log("Cannot send empty message", 'warn');
                return;
            }
            
            try {
                // Check if we have a valid session
                if (!sessionId) {
                    log("No session ID available - cannot send message", 'error');
                    return;
                }
                
                // Check for end interview commands - expanded to catch more variations
                const lowerInput = input.toLowerCase();
                const endInterviewPhrases = [
                    "end the interview", 
                    "end interview", 
                    "finish the interview", 
                    "complete the interview",
                    "stop the interview",
                    "conclude the interview",
                    "terminate the interview",
                    "end session",
                    "finish session",
                    "stop session",
                    "we're done",
                    "we are finished",
                    "that's all for today",
                    "interview over",
                    "let's finish now"
                ];
                
                // Check if the input contains any of the end interview phrases
                const isEndInterview = endInterviewPhrases.some(phrase => lowerInput.includes(phrase));
                
                if (isEndInterview) {
                    log("End interview command detected: " + input, 'info');
                    
                    // Add the user message to the UI
                    addMessage(input, 'user', false);
                    
                    // Display ending notification
                    const notificationElement = document.createElement('div');
                    notificationElement.className = 'message system-message';
                    notificationElement.textContent = "Ending interview...";
                    notificationElement.style.backgroundColor = '#f8d7da';
                    notificationElement.style.color = '#721c24';
                    notificationElement.style.padding = '10px';
                    notificationElement.style.margin = '10px 0';
                    notificationElement.style.borderRadius = '5px';
                    notificationElement.style.textAlign = 'center';
                    messageContainer.appendChild(notificationElement);
                    messageContainer.scrollTop = messageContainer.scrollHeight;
                    
                    // Play thank you message
                    const thankYouMessage = "Thank you for participating in this interview! Your insights are valuable to our research.";
                    addMessage(thankYouMessage, 'assistant', true);
                    
                    userInput.value = '';
                    
                    // End interview after TTS completes
                    ttsAudio.addEventListener('ended', () => {
                        endInterview();
                    }, { once: true });
                    
                    return;
                }
                
                // First update the UI
                addMessage(input, 'user');
                userInput.value = ''; // Clear input field
                
                // Stop speech recognition if it's running
                if (sttActive) {
                    stopSpeechRecognition();
                }
                
                // Send to API endpoint
                const addMessageEndpoint = `http://${window.location.hostname}:${apiPort}/api/session/${sessionId}/add_message`;
                log(`Sending message to API: "${input.substring(0, 30)}${input.length > 30 ? '...' : ''}"`, 'info');
                
                const response = await fetch(addMessageEndpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        content: input,
                        role: 'user'
                    })
                });
                
                // Check if the response was successful
                if (!response.ok) {
                    const errorText = await response.text();
                    log(`API error ${response.status}: ${errorText}`, 'error');
                    throw new Error(`API error ${response.status}: ${errorText}`);
                }
                
                const responseData = await response.json();
                
                if (!responseData.success) {
                    log(`API returned error: ${responseData.error || 'Unknown error'}`, 'error');
                    throw new Error(responseData.error || 'API reported failure');
                }
                
                log('Message sent successfully', 'info');
                
                // Poll for new messages after a short delay
                setTimeout(() => {
                    fetchLatestMessages();
                }, 2000);
                
                return true;
            } catch (error) {
                log(`Error sending message: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Initialize speech recognition
        function initSpeechRecognition() {
            log('Initializing speech recognition', 'stt');
            // Reset existing recognition if exists
            if (recognition) {
                try {
                    recognition.stop();
                } catch (e) {
                    // Ignore errors on stop
                }
                recognition = null;
            }
            
            try {
                window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
                recognition = new SpeechRecognition();
                recognition.lang = 'en-US';
                recognition.continuous = true;
                recognition.interimResults = true;
                
                // Set silence detection
                let finalTranscript = '';
                let silenceTimer = null;
                const SILENCE_THRESHOLD = 1500; // 1.5 seconds of silence
                
                recognition.onstart = function() {
                    sttActive = true;
                    updateStatus();
                    log('Speech recognition started', 'stt');
                    finalTranscript = '';
                };
                
                recognition.onresult = function(event) {
                    // Clear any existing silence timer
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                    }
                    
                    // Get the latest result
                    const result = event.results[event.results.length - 1];
                    const transcript = result[0].transcript;
                    
                    if (result.isFinal) {
                        // Add to the final transcript
                        finalTranscript += ' ' + transcript;
                        finalTranscript = finalTranscript.trim();
                        
                        // Display in the input box
                        userInput.value = finalTranscript;
                        
                        log(`Final transcript part: ${finalTranscript}`, 'stt');
                        
                        // Start silence detection timer to auto-submit after silence
                        silenceTimer = setTimeout(() => {
                            log('Silence detected, processing complete sentence', 'stt');
                            
                            // Only stop recognition if we have meaningful content
                            if (finalTranscript.trim().length > 3) {
                                try {
                                    recognition.stop();
                                } catch (e) {
                                    log(`Error stopping recognition: ${e.message}`, 'error');
                                }
                                
                                // Auto-submit after silence
                                setTimeout(() => {
                                    if (finalTranscript.trim()) {
                                        log('Auto-submitting message', 'stt');
                                        sendMessage(finalTranscript);
                                        userInput.value = '';
                                        finalTranscript = '';
                                    }
                                }, 500);
                            }
                        }, SILENCE_THRESHOLD);
                    } else {
                        // Display interim results in the input box
                        userInput.value = finalTranscript + ' ' + transcript;
                    }
                };
                
                recognition.onerror = function(event) {
                    log(`Speech recognition error: ${event.error}`, 'error');
                    sttActive = false;
                    updateStatus();
                };
                
                recognition.onend = function() {
                    log('Speech recognition ended', 'stt');
                    sttActive = false;
                    updateStatus();
                };
                
                return true;
            } catch (error) {
                log(`Error initializing speech recognition: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Start speech recognition
        function startSpeechRecognition() {
            try {
                // Check for microphone permissions
                log('Checking microphone permissions...', 'stt');
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        log('Microphone permission granted', 'info');
                        
                        // Initialize recognition if needed
                        if (!recognition) {
                            initSpeechRecognition();
                        }
                        
                        // Start recognition
                        if (recognition) {
                            try {
                                recognition.start();
                                sttActive = true;
                                updateStatus();
                                log('Starting speech recognition', 'stt');
                            } catch (e) {
                                log(`Error starting recognition: ${e.message}`, 'error');
                            }
                        }
                        
                        // Stop the stream we used just for permission
                        stream.getTracks().forEach(track => track.stop());
                    })
                    .catch(err => {
                        log(`Microphone permission denied: ${err.message}`, 'error');
                    });
            } catch (error) {
                log(`Error requesting microphone permission: ${error.message}`, 'error');
            }
        }
        
        // Stop speech recognition
        function stopSpeechRecognition() {
            if (recognition) {
                try {
                    recognition.stop();
                    log('Speech recognition stopped', 'stt');
                } catch (e) {
                    log(`Error stopping recognition: ${e.message}`, 'error');
                }
                sttActive = false;
                updateStatus();
            }
        }
        
        // Play text-to-speech
        async function playTTS(text) {
            if (!text) {
                log('No text provided for TTS', 'warn');
                return false;
            }
            
            try {
                log(`Starting TTS for text: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}"`, 'tts');
                
                // Stop any previous playback
                stopTTS();
                
                // Set status
                ttsActive = true;
                updateStatus();
                
                // Try ElevenLabs TTS with retry mechanism
                return await tryTTSWithRetry(text);
            } catch (error) {
                log(`Error playing TTS: ${error.message}`, 'error');
                ttsActive = false;
                updateStatus();
                return false;
            }
        }
        
        // Try TTS with retry mechanism
        async function tryTTSWithRetry(text, maxRetries = 3) {
            let attempt = 0;
            let lastError = null;
            
            while (attempt < maxRetries) {
                try {
                    attempt++;
                    log(`TTS attempt ${attempt}/${maxRetries} for text: "${text.substring(0, 30)}${text.length > 30 ? '...' : ''}"`, 'tts');
                    
                    // Get ElevenLabs TTS
                    log(`Sending TTS request to ${window.location.hostname}:${apiPort}/api/text_to_speech_elevenlabs`, 'tts');
                    const response = await fetch(`http://${window.location.hostname}:${apiPort}/api/text_to_speech_elevenlabs`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: text
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`TTS request failed with status ${response.status}`);
                    }
                    
                    const audioData = await response.arrayBuffer();
                    
                    // Create a Blob from the audio data
                    const audioBlob = new Blob([audioData], { type: 'audio/mpeg' });
                    
                    // Create a URL for the Blob
                    const audioUrl = URL.createObjectURL(audioBlob);
                    
                    // Create a new Audio element
                    const newTtsAudio = new Audio(audioUrl);
                    
                    // Set up event listeners for the new Audio element
                    newTtsAudio.autoplay = true;
                    newTtsAudio.controls = false;
                    newTtsAudio.muted = false;
                    newTtsAudio.volume = 1;
                    
                    newTtsAudio.addEventListener('play', () => {
                        log("Audio playback started", 'tts');
                        ttsActive = true;
                        updateStatus();
                    });
                    
                    newTtsAudio.addEventListener('ended', () => {
                        log("Audio playback ended", 'tts');
                        ttsActive = false;
                        updateStatus();
                    });
                    
                    newTtsAudio.addEventListener('error', (event) => {
                        let errorMessage = "Unknown audio error";
                        
                        // Get more detailed error information
                        if (event.error) {
                            switch (event.error.code) {
                                case MediaError.MEDIA_ERR_ABORTED:
                                    errorMessage = "Audio playback aborted";
                                    break;
                                case MediaError.MEDIA_ERR_NETWORK:
                                    errorMessage = "Network error during audio loading";
                                    break;
                                case MediaError.MEDIA_ERR_DECODE:
                                    errorMessage = "Audio decoding error";
                                    break;
                                case MediaError.MEDIA_ERR_SRC_NOT_SUPPORTED:
                                    errorMessage = "Audio format not supported";
                                    break;
                                default:
                                    errorMessage = `Unknown error: ${event.error.code}`;
                            }
                        }
                        
                        log(`TTS Audio error: ${errorMessage}`, 'error');
                        ttsActive = false;
                        updateStatus();
                    });
                    
                    return true;
                } catch (error) {
                    log(`TTS attempt ${attempt}/${maxRetries} failed: ${error.message}`, 'error');
                    lastError = error;
                }
            }
            
            log(`All TTS attempts failed: ${lastError.message}`, 'error');
            ttsActive = false;
            updateStatus();
            return false;
        }
        
        // Stop TTS
        function stopTTS() {
            if (ttsAudio) {
                ttsAudio.pause();
                ttsAudio.currentTime = 0;
                ttsAudio = null;
                log('TTS stopped', 'tts');
            }
        }
        
        // Log a message to the console
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            
            // Create standard console message
            console.log(`[${type}] ${message}`);
            
            // Add to debug log (inside collapsible panel)
            if (document.getElementById('debug-log')) {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${timestamp} - ${message}`;
                document.getElementById('debug-log').appendChild(entry);
                
                // Auto-scroll to bottom
                const debugLog = document.getElementById('debug-log');
                debugLog.scrollTop = debugLog.scrollHeight;
            }
            
            // Add to always visible debug log
            if (document.getElementById('debug-log-visible')) {
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.textContent = `${timestamp} - ${message}`;
                document.getElementById('debug-log-visible').appendChild(entry);
                
                // Auto-scroll to bottom
                const visibleLog = document.getElementById('debug-log-visible');
                visibleLog.scrollTop = visibleLog.scrollHeight;
            }
        }
        
        // Initialize UI components
        function initUI() {
            log("Initializing UI components", 'info');
            
            // Reset UI state
            userInput.disabled = true;
            sendMessageBtn.disabled = true;
            endInterviewBtn.disabled = true;
            
            // Set placeholder text
            userInput.placeholder = "Connecting to interview session...";
            
            // Clear message container
            messageContainer.innerHTML = '<div class="message system-message">Connecting to interview session...</div>';
            
            // Initialize connection status
            connectionStatus.className = 'status-indicator status-inactive';
            connectionStatusText.textContent = 'Connecting...';
            
            // Initialize any other UI components
            if (document.getElementById('tts-status')) {
                document.getElementById('tts-status').className = 'status-indicator status-inactive';
                document.getElementById('tts-status-text').textContent = 'Inactive';
            }
            
            if (document.getElementById('stt-status')) {
                document.getElementById('stt-status').className = 'status-indicator status-inactive';
                document.getElementById('stt-status-text').textContent = 'Inactive';
            }
            
            log("UI components initialized", 'info');
        }
        
        // Setup collapsible panels
        function setupCollapsiblePanels() {
            log("Setting up collapsible panels", 'info');
            
            const headers = document.querySelectorAll('.collapsible-header');
            if (!headers || headers.length === 0) {
                log("No collapsible headers found", 'warn');
                return;
            }
            
            log(`Found ${headers.length} collapsible panels`, 'info');
            
            headers.forEach((header, index) => {
                log(`Setting up panel ${index + 1}: ${header.textContent.trim()}`, 'info');
                
                header.addEventListener('click', function() {
                    log(`Panel clicked: ${this.textContent.trim()}`, 'info');
                    
                    // Get the content element that follows this header
                    const content = this.nextElementSibling;
                    if (!content) {
                        log("No content element found for header", 'error');
                        return;
                    }
                    
                    // Get the toggle icon if present
                    const toggleIcon = this.querySelector('.toggle-icon');
                    
                    // Check if panel is currently expanded
                    if (content.style.maxHeight && content.style.maxHeight !== '0px') {
                        // Collapse panel
                        log(`Collapsing panel: ${this.textContent.trim()}`, 'info');
                        content.style.maxHeight = null;
                        if (toggleIcon) toggleIcon.textContent = '+';
                    } else {
                        // Expand panel
                        log(`Expanding panel: ${this.textContent.trim()}`, 'info');
                        content.style.maxHeight = content.scrollHeight + 'px';
                        if (toggleIcon) toggleIcon.textContent = '−';
                    }
                });
            });
            
            // Expand the debug log panel by default
            try {
                const debugLogHeader = document.getElementById('debug-log-header');
                if (debugLogHeader) {
                    log("Attempting to expand debug log panel by default", 'info');
                    const content = debugLogHeader.nextElementSibling;
                    const toggleIcon = debugLogHeader.querySelector('.toggle-icon');
                    
                    // Force expand
                    if (content) {
                        content.style.maxHeight = content.scrollHeight + 'px';
                        if (toggleIcon) toggleIcon.textContent = '−';
                        log("Debug log panel expanded by default", 'info');
                    } else {
                        log("Could not find content element for debug log header", 'warn');
                    }
                } else {
                    log("Debug log header not found", 'warn');
                }
            } catch (error) {
                log(`Error expanding debug panel: ${error.message}`, 'error');
            }
            
            log("Collapsible panels setup complete", 'info');
        }
    </script>
</body>
</html>